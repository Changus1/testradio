// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
import { Big } from "big.js";

// BEGIN EXTRA CODE

//https://css-tricks.com/using-css-transitions-auto-dimensions/
async function collapseSection(element, resolve) {
	return new Promise(resolve => {
		// get the height of the element's inner content, regardless of its actual size
		var sectionHeight = element.scrollHeight;

		// temporarily disable all css transitions
		var elementTransition = element.style.transition;
		element.style.transition = '';

		// on the next frame (as soon as the previous style change has taken effect),
		// explicitly set the element's height to its current pixel height, so we 
		// aren't transitioning out of 'auto'
		requestAnimationFrame(function() {
			element.style.height = sectionHeight + 'px';
			element.style.transition = elementTransition;

			// on the next frame (as soon as the previous style change has taken effect),
			// have the element transition to height: 0
			requestAnimationFrame(function() {
				element.style.height = 0 + 'px';
				resolve();
			});
		});

		// mark the section as "currently collapsed"
		element.classList.add('collapsed');
	});
}

async function expandSection(element, resolve) {
	return new Promise(resolve => {
		// get the height of the element's inner content, regardless of its actual size
		var sectionHeight = element.scrollHeight;

		// have the element transition to the height of its inner content
		element.style.height = sectionHeight + 'px';

		// when the next css transition finishes (which should be the one we just triggered)
		element.addEventListener('transitionend', function endListener(e) {
			// remove this event listener so it only gets triggered once
			element.removeEventListener('transitionend', endListener);

			// remove "height" from the element's inline styles, so it can return to its initial value
			element.style.height = null;
			resolve();
		});

		// mark the section as "currently not collapsed"
		element.classList.remove('collapsed');
	});
}

// If a nav link is clicked, the menu should collapse
function addClickListeners(elem) {
	elem.querySelectorAll('li:not(.mx-navigationtree-has-items) > a').forEach(function(el) {
		el.addEventListener('click', function collapseOnClick() {
			// Remove this listener, so it doesn't stay after being clicked
			el.removeEventListener('click', collapseOnClick);
			collapseSection(elem);
			let hamburgerBtn = document.querySelector('.byu-header__nav-mobile-btn')
			if (hamburgerBtn) {
				hamburgerBtn.classList.remove('is-active');
			}
		});
	});
}
// END EXTRA CODE

/**
 * @returns {Promise.<void>}
 */
export async function JS_MobileNav_Toggle() {
	// BEGIN USER CODE
	
	let hamburgerBtn, mobileNav;

	// Toggle icon: hamburger <=> X
	if (hamburgerBtn = document.querySelector('.byu-header__nav-mobile-btn')) {
		hamburgerBtn.classList.toggle('is-active');
	}

	// Toggle mobile navigation dropdown
	if (mobileNav = document.querySelector('.byu-header__nav-mobile')) {
		if (mobileNav.classList.contains('collapsed')) {
			await expandSection(mobileNav);
			addClickListeners(mobileNav);
		} else {
			await collapseSection(mobileNav);
		}
	}

	// END USER CODE
}
